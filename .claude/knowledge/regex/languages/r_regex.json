{
  "r_regex_specifics": {
    "engines": {
      "posix_ere": {
        "description": "Default engine in base R functions",
        "activation": "perl = FALSE (default)",
        "features": ["Basic character classes", "Quantifiers", "Alternation", "Anchors"],
        "limitations": ["No lookahead/lookbehind", "No non-capturing groups", "No named groups"],
        "functions": ["grep()", "grepl()", "gsub()", "sub()", "regexpr()", "regmatches()"]
      },
      "pcre": {
        "description": "Perl-compatible regular expressions",
        "activation": "perl = TRUE",
        "features": ["Lookahead/lookbehind", "Non-capturing groups", "Named groups", "Atomic groups", "Recursive patterns"],
        "functions": ["grep()", "grepl()", "gsub()", "sub()", "regexpr()", "regmatches()"]
      },
      "tre": {
        "description": "TRE engine (rarely used)",
        "activation": "useBytes = TRUE with specific conditions",
        "features": ["Approximate matching", "Unicode support"],
        "use_cases": ["Fuzzy matching", "Text similarity"]
      }
    },
    "base_r_functions": [
      {
        "function": "grep(pattern, x, ...)",
        "purpose": "Find matching elements",
        "returns": "Indices of matching elements",
        "example": "grep('^A', c('Apple', 'Banana', 'Apricot'))",
        "result": "[1] 1 3"
      },
      {
        "function": "grepl(pattern, x, ...)",
        "purpose": "Test for matches",
        "returns": "Logical vector",
        "example": "grepl('^A', c('Apple', 'Banana', 'Apricot'))",
        "result": "[1] TRUE FALSE TRUE"
      },
      {
        "function": "gsub(pattern, replacement, x, ...)",
        "purpose": "Replace all matches",
        "returns": "Character vector with replacements",
        "example": "gsub('[0-9]', 'X', c('test123', 'abc456'))",
        "result": "[1] 'testXXX' 'abcXXX'"
      },
      {
        "function": "sub(pattern, replacement, x, ...)",
        "purpose": "Replace first match only",
        "returns": "Character vector with first replacement",
        "example": "sub('[0-9]', 'X', c('test123', 'abc456'))",
        "result": "[1] 'testX23' 'abcX56'"
      },
      {
        "function": "regexpr(pattern, text, ...)",
        "purpose": "Find first match position and length",
        "returns": "Integer vector with attributes",
        "example": "regexpr('[0-9]+', 'abc123def456')",
        "result": "[1] 4\nattr(,\"match.length\")\n[1] 3"
      },
      {
        "function": "regmatches(m, regexpr(...))",
        "purpose": "Extract matched strings",
        "returns": "Character vector of matches",
        "example": "regmatches('abc123def456', regexpr('[0-9]+', 'abc123def456'))",
        "result": "[1] '123'"
      }
    ],
    "stringr_functions": [
      {
        "function": "str_detect(string, pattern)",
        "purpose": "Test for pattern presence",
        "returns": "Logical vector",
        "example": "str_detect(c('apple', 'banana'), '^a')",
        "result": "[1] TRUE FALSE",
        "base_equivalent": "grepl()"
      },
      {
        "function": "str_extract(string, pattern)",
        "purpose": "Extract first match",
        "returns": "Character vector",
        "example": "str_extract('abc123def456', '[0-9]+')",
        "result": "[1] '123'",
        "base_equivalent": "regmatches() + regexpr()"
      },
      {
        "function": "str_extract_all(string, pattern)",
        "purpose": "Extract all matches",
        "returns": "List of character vectors",
        "example": "str_extract_all('abc123def456', '[0-9]+')[[1]]",
        "result": "[1] '123' '456'",
        "base_equivalent": "regmatches() + gregexpr()"
      },
      {
        "function": "str_replace(string, pattern, replacement)",
        "purpose": "Replace first match",
        "returns": "Character vector",
        "example": "str_replace('abc123def456', '[0-9]+', 'NUM')",
        "result": "[1] 'abcNUMdef456'",
        "base_equivalent": "sub()"
      },
      {
        "function": "str_replace_all(string, pattern, replacement)",
        "purpose": "Replace all matches",
        "returns": "Character vector",
        "example": "str_replace_all('abc123def456', '[0-9]+', 'NUM')",
        "result": "[1] 'abcNUMdefNUM'",
        "base_equivalent": "gsub()"
      },
      {
        "function": "str_match(string, pattern)",
        "purpose": "Extract matches with capture groups",
        "returns": "Character matrix",
        "example": "str_match('John: 25', '(\\\\w+): (\\\\d+)')",
        "result": "     [,1]       [,2]   [,3]\n[1,] 'John: 25' 'John' '25'",
        "base_equivalent": "regmatches() + regexpr() with capture groups"
      }
    ],
    "r_specific_patterns": {
      "character_classes": {
        "posix_classes": {
          "[:alnum:]": "Alphanumeric characters",
          "[:alpha:]": "Alphabetic characters", 
          "[:digit:]": "Digits 0-9",
          "[:lower:]": "Lowercase letters",
          "[:upper:]": "Uppercase letters",
          "[:punct:]": "Punctuation characters",
          "[:space:]": "Whitespace characters"
        },
        "r_equivalents": {
          "\\\\d": "[[:digit:]]",
          "\\\\w": "[[:alnum:]_]",
          "\\\\s": "[[:space:]]"
        }
      },
      "escaping_rules": {
        "single_quotes": "Use single backslash: '\\\\d+'",
        "double_quotes": "Use double backslash: \"\\\\\\\\d+\"",
        "raw_strings": "Not available in base R",
        "recommendation": "Use single quotes for regex patterns when possible"
      },
      "named_groups": {
        "pcre_syntax": "(?<name>pattern) - requires perl = TRUE",
        "extraction": "Use str_match() with stringr or regmatches() with base R",
        "example": "str_match('John: 25', '(?<name>\\\\w+): (?<age>\\\\d+)')"
      }
    },
    "common_r_patterns": [
      {
        "purpose": "Extract numbers from text",
        "pattern": "\\\\d+",
        "example": "str_extract_all('Price: $19.99, Tax: $2.50', '\\\\d+\\\\.\\\\d+')",
        "result": "[[1]]\n[1] '19.99' '2.50'"
      },
      {
        "purpose": "Split column names (camelCase to words)",
        "pattern": "(?<=[a-z])(?=[A-Z])",
        "example": "str_split('firstName', '(?<=[a-z])(?=[A-Z])')[[1]]",
        "result": "[1] 'first' 'Name'",
        "requires": "perl = TRUE"
      },
      {
        "purpose": "Validate R variable names",
        "pattern": "^[a-zA-Z.][a-zA-Z0-9._]*$",
        "example": "str_detect(c('valid_name', '2invalid', '.valid'), '^[a-zA-Z.][a-zA-Z0-9._]*$')",
        "result": "[1] TRUE FALSE TRUE"
      },
      {
        "purpose": "Extract file extensions",
        "pattern": "\\\\.[^.]*$",
        "example": "str_extract(c('file.txt', 'document.pdf'), '\\\\.[^.]*$')",
        "result": "[1] '.txt' '.pdf'"
      },
      {
        "purpose": "Clean whitespace in data frames",
        "pattern": "^\\\\s+|\\\\s+$",
        "example": "str_replace_all(' messy data ', '^\\\\s+|\\\\s+$', '')",
        "result": "[1] 'messy data'"
      }
    ],
    "performance_tips": {
      "vectorization": "R regex functions are vectorized - process entire vectors at once",
      "compilation": "Use compiled patterns with stringr for repeated operations",
      "engine_choice": "Use perl = TRUE for complex patterns, FALSE for simple ones",
      "memory_usage": "Be careful with str_extract_all() on large datasets",
      "alternatives": {
        "simple_patterns": "Use startsWith(), endsWith(), %in% when appropriate",
        "complex_parsing": "Consider tidyr::separate() for structured data",
        "large_data": "Use data.table::fread() with regex options"
      }
    },
    "common_gotchas": [
      {
        "issue": "Double escaping in double quotes",
        "wrong": "gsub(\"\\\\d+\", \"NUM\", text)",
        "correct": "gsub(\"\\\\\\\\d+\", \"NUM\", text) or gsub('\\\\d+', 'NUM', text)",
        "solution": "Prefer single quotes for regex patterns"
      },
      {
        "issue": "POSIX vs PCRE behavior differences",
        "example": "Lookbehind (?<=...) only works with perl = TRUE",
        "solution": "Always specify perl = TRUE/FALSE explicitly"
      },
      {
        "issue": "Named groups syntax confusion",
        "posix": "Not supported",
        "pcre": "(?<name>pattern) with perl = TRUE",
        "solution": "Use numbered capture groups for POSIX compatibility"
      },
      {
        "issue": "Case sensitivity with different locales",
        "problem": "[A-Z] may include accented characters in some locales",
        "solution": "Use [:upper:] or specify ignore.case = TRUE"
      }
    ],
    "best_practices": [
      "Always specify perl = TRUE/FALSE explicitly",
      "Use single quotes for regex patterns to avoid double escaping",
      "Prefer stringr functions for consistency and readability",
      "Test patterns with both perl = TRUE and FALSE if compatibility matters",
      "Use str_view() from stringr to visualize matches during development",
      "Consider fixed = TRUE for literal string matching (faster)",
      "Use ignore.case = TRUE instead of complex case-insensitive patterns"
    ]
  }
}